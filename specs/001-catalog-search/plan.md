# Implementation Plan: Product Search and Listing (Catalog Search)

**Branch**: `001-catalog-search` | **Date**: 2025-11-29 | **Spec**: `specs/001-catalog-search/spec.md`  
**Input**: Feature specification from `specs/001-catalog-search/spec.md`

**Note**: This plan is generated by `/speckit.plan` and must follow the VShop constitution plus `docs/architecture.md`, `docs/coding-conventions.md`, `docs/testing-strategy.md`, and `docs/ai-collaboration-guide.md`.

## Summary

Implement the initial catalog search experience for VShop: a dual-mode **Landing/Search** page that lets users search products by text and see a responsive grid of results with title, price, image, “New Arrival” badge, and a visual “add” micro-interaction.  
The implementation will use **Next.js App Router**, **TypeScript**, **Tailwind CSS** (mobile-first) and **Shadcn UI components**, with a **BFF endpoint** backed by local mocks shaped like a MercadoLibre-style response (query, paging, results with price, condition, shipping, installments, reviews).

## Technical Context

<!--
  ACTION REQUIRED: Replace the content in this section with the technical details
  for the project. The structure here is presented in advisory capacity to guide
  the iteration process.
-->

**Language/Version**: TypeScript on Next.js App Router (Node 18+)  
**Primary Dependencies**: Next.js, React, Tailwind CSS, Shadcn UI (Radix-based), Biome, Jest + Testing Library  
**Storage**: Local JSON mocks for catalog data (no external API integration in this iteration)  
**Testing**: Jest + @testing-library/react + @testing-library/jest-dom; Gherkin `.feature` files as acceptance documentation (no e2e runner)  
**Target Platform**: Web (mobile-first responsive design; desktop-optimized per spec)  
**Project Type**: Web application (Next.js host with modular Clean Architecture modules)  
**Performance Goals**: Users see a visible state (loading/results/empty/error) within ~2 seconds for 95% of searches, including ~400 ms simulated latency; UI interactions remain smooth on mid-range mobile devices.  
**Constraints**: Must respect modular Clean Architecture (domain/application/infrastructure/ui + BFF), avoid new heavy runtime deps, and rely on mocks for the backend; design must be mobile-first and align with VShop visual identity.  
**Scale/Scope**: Single-page catalog search experience with a few hundred mock products; paging metadata is present in mocks but full pagination is out of scope for this iteration.

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- **Modular Clean Architecture & BFF boundaries (Principle I)**  
  - This feature will live primarily in the `catalog` module:  
    - `domain`: `Product` entity + repository interfaces (already present / extended only if needed).  
    - `application`: `SearchProducts` use case orchestrating repository calls and query normalization.  
    - `infrastructure`: mock repository reading from a local JSON catalog shaped like the provided MercadoLibre-style response.  
    - `ui`: `SearchView` + related components/hooks composed by `src/app/page.tsx`.  
  - BFF endpoint `GET /api/products` will be implemented in `src/app/api/products/route.ts`, validating `q`, delegating to `SearchProducts`, and mapping to a DTO (`{ query, paging, results[] }`).  
  - UI will call the BFF via HTTP or module hooks, never importing infrastructure directly.  
  - **Status**: PASS (no architecture rule violations planned).

- **Testing-As-Design (Principle II)**  
  - Acceptance behavior is documented in `tests/acceptance/features/catalog-search-products.feature` (search success, empty, error, modes).  
  - Unit tests: `tests/unit/catalog/SearchProducts.test.ts` will be created/extended to cover empty query, query trimming, repository delegation, error propagation where applicable.  
  - Component tests: `tests/components/catalog/SearchView.test.tsx` will cover Landing vs Search modes, loader, empty state, error state, product cards, and scroll behavior.  
  - No new e2e framework will be introduced.  
  - **Status**: PASS.

- **Documentation & AI collaboration (Principle III)**  
  - BFF contract changes for `/api/products` will be documented in `docs/bff-api.md`.  
  - Any significant architectural nuance (e.g., how paging metadata is represented without implementing full pagination) will be captured as a short ADR if needed.  
  - Plan and spec already follow SpecKit; AI assistants will respect module boundaries and testing expectations.  
  - **Status**: PASS.

- **Small e-commerce scope & simplicity (Principle IV)**  
  - Feature avoids implementing full pagination, sorting, cart, or external API integration; focus is on the core search/listing experience and states.  
  - No new heavy runtime dependencies beyond Shadcn UI (based on existing Tailwind/React stack).  
  - UI components will remain presentational; query logic lives in hooks/use cases and BFF.  
  - **Status**: PASS.

- **User-centric slices & Git discipline (Principle V)**  
  - Work will be organized around the P1/P2/P3 user stories from the feature spec.  
  - Tasks will be later broken down via `/speckit.tasks`; commits will follow Conventional Commits with scopes like `catalog`, `bff`, or `ui`.  
  - **Status**: PASS.

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)
<!--
  ACTION REQUIRED: Replace the placeholder tree below with the concrete layout
  for this feature. Delete unused options and expand the chosen structure with
  real paths (e.g., apps/admin, packages/something). The delivered plan must
  not include Option labels.
-->

```text
src/
  app/
    api/
      products/
        route.ts            # BFF endpoint: GET /api/products?q=<string>
    page.tsx                # Main catalog search page composing catalog UI module

  modules/
    catalog/
      domain/
        entities/
          Product.ts        # Product entity
        repositories/
          ProductRepository.ts
      application/
        use-cases/
          SearchProducts.ts # Use case orchestrating product search
      infrastructure/
        data/
          products-list.json     # Mock catalog shaped like ML-style response
        repositories/
          MockProductRepository.ts
      ui/
        components/
          SearchView.tsx         # Page-level search experience (Landing/Search modes)
          ProductCard.tsx       # Card with image, title, price, badges, add micro-interaction
        hooks/
          useSearchProducts.ts  # Hook to talk to BFF and expose loading/error/data

tests/
  unit/
    catalog/
      SearchProducts.test.ts
  components/
    catalog/
      SearchView.test.tsx
      ProductCard.test.tsx
  acceptance/
    features/
      catalog-search-products.feature
```

**Structure Decision**: Use the existing modular Clean Architecture layout under `src/modules/catalog` with `src/app` as host and BFF, plus tests colocated under `tests/` by module and level as defined in `docs/testing-strategy.md`.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |
